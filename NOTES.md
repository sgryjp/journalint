# 開発メモ

## エラー例

- minute value of an env of time-range exceeds 99: `- 09:45-23:100`

## 2023-05-04

大まかな構造を chumsky で実施し、パース失敗したならそのときに出てきたエラーを
diagnostic として返す。

大まかな構造をパースした結果は AST に相当するデータとする。

その構造に対して各種の lint を追加で行う。 lint は、基本的にエラー終了しない。

## 2023-07-15

- 日記ファイルは markdown ではあるが、markdown としてのパースは意図的に行ってい
  ない
- markdown の YAML Front-matter と、作業一つ一つを記録する箇条書き（エントリ）だ
  けを解析の対象とする
- エントリ以外の markdown 文書の行は、すべて無視する
- 以上の方針から本文の解析は、エントリとしての解釈を試みて、reject されたなら無
  視すべき行として accept する
- 「無視すべき行」はどんな内容であっても確実に accept されるものとする
- よって、パーサー全体として解析に失敗することは無い

ただ、タイポ等によりエントリ行がエントリ行として accept されない内容になっている
と見逃すことになるため、linter としてはこの問題に対策をしたい。とはいえ、エント
リ行のような非エントリ行との混同も避けたい。そこで、以下のような方針を採用するこ
ととした:

- エントリ中、時刻のペアの解析に失敗した場合、エントリとして reject する
- エントリ中、時刻のペアより後の要素の解析に失敗した場合、エントリとして accept
  する

要素の解析失敗時にも accept するため、エラーリカバリを実装するということになる。

    - 09:00-10:00 X123456 012 1.00 foo: bar: Developer mtg␤
      ─┬─── ─┬─── ─┬───── ─┬─ ─┬── ─┬─────────────────────
       │     │     │       │   │    ╰── Activity
       │     │     │       │   ╰── Duration
       │     │     │       ╰── Code[1]
       │     │     ╰── Code[0]
       │     ╰── Time
       ╰── Time

## 2023-07-18

リカバリした上での accept は reject の一種とみなされるらしい。よって `A.or(B)`
のうち A がリカバリした上で accept できるとしても B の評価も行われてしまうようだ
った。したがって、次のようにパーサーを構成して:

    journal_entry.or(other_line)

journal_entry がリカバリした上で accept すると、other_line として解釈される。

色々試したが、一回のパースで全部解釈する今のやり方を踏襲するなら、上記で言う
other_line をリカバリで実装する手があると思われる。ただし、この場合は other_line
でリカバリした際に記録されるエラーと、 journal_entry 内の各要素のパースエラーで
リカバリした際に記録されるエラーとを後で選別しなければならなくなる。これがリーズ
ナブルなのかどうかは、本日時点では分からない。

---

その後に少し検討を進めたところ、そもそも Valid な文法としてエラー node を AST と
して定義しておき、`foo().or(erroneous_foo())` という感じでパースすれば絶対に失敗
しないパーサーとして対応できる。

なお、`chumsky::Parser::or` で実装すると失敗理由が不明になるので
`chumsky::Parser::or_else` で実装すると良い感じだった。

## 2023-07-30

比較的マジメに AST っぽいものを作って処理するアプローチに変えたので、Ruff の設計
を改めて勉強させてもらった。まず文法チェック (lint) は AST を Visitor パターンで
traverse する中で、ある種別のノードを発見したときに呼ばれる処理、という形で複数
のチェック処理を実行して Diagnostic を生成している。 Auto-fix については、Edit
のリストである Fix を、 Diagnostic を生成する際に付与可能なルールで、かつ付与す
べきオプションが指定されているようであれば付与するようになっている。これの実行処
理は、トリガーする側がどの Diagnostic に対する fix なのかを指定してきているはず
なので、おそらく素直に該当する Diagnostic から fix を取り出して実行するだけだと
思う。

## 2023-08-06

front matter の date, start, end を別々の文法上のノードとして定義してパーサーを
構成していたが、その実現のために (date or start or end) というパーサーを repeat
させていた。正常系であれば、たしかに問題なく順不同で各フィールドの値を区別して取
得できるのだけれど、一つでも不足または accept 不可能な内容になっていたりすると
、repeat の部分でのエラーということになり分かりにくいエラーメッセージが表示され
る問題が起こった (unexpectedly found an end of input といった内容)。これは、おそ
らくパーサーとしては素直でない作りを採用していたことに根本原因があると考え、素直
に front matter のフィールド解釈はフィールドの種別を区別せず行うように変更した方
が良いかもしれない。

## 2023-08-19

Quick Fix / Code action の実装を開始する。LSP 仕様で関連するメッセージは
`textDocument/codeAction`。VSCode で軽く試すと、カーソル移動のたびに
`textDocument/codeAction` のメッセージが飛んできて非同期な実行を要求される。また
、それを無視する実装のままでカーソルを動かしたりすると `$/cancelRequest` の通知
が飛んでくる。
