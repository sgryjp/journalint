# 開発メモ

## エラー例

- minute value of an env of time-range exceeds 99: `- 09:45-23:100`

## 2023-07-15

- 日記ファイルは markdown ではあるが、markdown としてのパースは意図的に行っていない
- markdown の YAML Front-matter と、作業一つ一つを記録する箇条書き（エントリ）だけを解析の対象とする
- エントリ以外の markdown 文書の行は、すべて無視する
- 以上の方針から本文の解析は、エントリとしての解釈を試みて、reject されたなら無視すべき行として accept する
- 「無視すべき行」はどんな内容であっても確実に accept されるものとする
- よって、パーサー全体として解析に失敗することは無い

ただ、タイポ等によりエントリ行がエントリ行として accept されない内容になっていると見逃すことになるため、linter としてはこの問題に対策をしたい。とはいえ、エントリ行のような非エントリ行との混同も避けたい。そこで、以下のような方針を採用することとした:

- エントリ中、時刻のペアの解析に失敗した場合、エントリとして reject する
- エントリ中、時刻のペアより後の要素の解析に失敗した場合、エントリとして accept する

要素の解析失敗時にも accept するため、エラーリカバリを実装するということになる。

    - 09:00-10:00 X123456 012 1.00 foo: bar: Developer mtg␤
      ─┬─── ─┬─── ─┬───── ─┬─ ─┬── ─┬─────────────────────
       │     │     │       │   │    ╰── Activity
       │     │     │       │   ╰── Duration
       │     │     │       ╰── Code[1]
       │     │     ╰── Code[0]
       │     ╰── Time
       ╰── Time

## 2023-07-18

リカバリした上での accept は reject の一種とみなされるらしい。
よって `A.or(B)` のうち A がリカバリした上で accept できるとしても
B の評価も行われてしまうようだった。
したがって、次のようにパーサーを構成して:

    journal_entry.or(other_line)

journal_entry がリカバリした上で accept すると、other_line として解釈される。

色々試したが、一回のパースで全部解釈する今のやり方を踏襲するなら、
上記で言う other_line をリカバリで実装する手があると思われる。
ただし、この場合は other_line でリカバリした際に記録されるエラーと、
journal_entry 内の各要素のパースエラーでリカバリした際に記録されるエラーとを
後で選別しなければならなくなる。
これがリーズナブルなのかどうかは、本日時点では分からない。

---

その後に少し検討を進めたところ、そもそも Valid な文法としてエラー node を
AST として定義しておき、`foo().or(erroneous_foo())` という感じでパースすれば
絶対に失敗しないパーサーとして対応できる。

なお、`chumsky::Parser::or` で実装すると失敗理由が不明になるので
`chumsky::Parser::or_else` で実装すると良い感じだった。

## 2023-07-30

比較的マジメに AST っぽいものを作って処理するアプローチに変えたので、
Ruff の設計を改めて勉強させてもらった。
まず文法チェック (lint) は AST を Visitor パターンで traverse する中で、
ある種別のノードを発見したときに呼ばれる処理、
という形で複数のチェック処理を実行して Diagnostic を生成している。
Auto-fix については、Edit のリストである Fix を、
Diagnostic を生成する際に付与可能なルールで、
かつ付与すべきオプションが指定されているようであれば付与するようになっている。
これの実行処理は、トリガーする側がどの Diagnostic に対する fix なのかを
指定してきているはずなので、おそらく素直に該当する Diagnostic から fix を
取り出して実行するだけだと思う。

## 2023-08-06

front matter の date, start, end を別々の文法上のノードとして定義して
パーサーを構成していたが、その実現のために (date or start or end)
というパーサーを repeat させていた。正常系であれば、たしかに問題なく
順不同で各フィールドの値を区別して取得できるのだけれど、一つでも不足
または accept 不可能な内容になっていたりすると、repeat の部分での
エラーということになり分かりにくいエラーメッセージが表示される問題が起こった
(unexpectedly found an end of input といった内容)。
これは、おそらくパーサーとしては素直でない作りを採用していたことに
根本原因があると考え、素直に front matter のフィールド解釈は
フィールドの種別を区別せず行うように変更した方が良いかもしれない。

## 2023-08-19

Quick Fix / Code action の実装を開始する。LSP 仕様で関連するメッセージは
`textDocument/codeAction`。VSCode で軽く試すと、カーソル移動のたびに
`textDocument/codeAction` のメッセージが飛んできて非同期な実行を要求される。
また、それを無視する実装のままでカーソルを動かしたりすると
`$/cancelRequest` の通知が飛んでくる。
